---
schema: EconSchema
version: 1
aspectRatio: 0.7
params:

- {name: p1, value: 4}
- {name: p1new, value: 9}
- {name: p2, value: 2}
- {name: m, value: 360}

- {name: a, value: 1}
- {name: b, value: 1}

- {name: showMORE, value: false}
- {name: showLESS, value: false}

- {name: howmuch, value: 0}

calcs:
  s1: (params.a)/((params.a)+(params.b)) # share of income spent on good 1
  s2: (1)-(calcs.s1) # share of income spent on good 2
  x1old: (calcs.s1)*(params.m)/(params.p1) # optimal qty good 1 at old prices
  x2old: (calcs.s2)*(params.m)/(params.p2) # optimal qty good 2 at old prices
  uold: ((calcs.x1old)^(params.a))*((calcs.x2old)^(params.b)) # max utility at old prices

  x1new: (calcs.s1)*(params.m)/(params.p1new) # optimal qty good 1 at new prices
  x2new: (calcs.s2)*(params.m)/(params.p2) # optimal qty good 2 at new prices
  unew: ((calcs.x1new)^(params.a))*((calcs.x2new)^(params.b)) # max utility at new prices

  deltaCS: (calcs.s1)*(params.m)*log((params.p1new)/(params.p1))
  x1deltaCS: (calcs.s1)*((params.m)+(calcs.deltaCS))/(params.p1new) 
  x2deltaCS: (calcs.s2)*((params.m)+(calcs.deltaCS))/(params.p2) 
  udeltaCS: ((calcs.x1deltaCS)^(params.a))*((calcs.x2deltaCS)^(params.b))


  # expenditure function at old utility and old prices (=income)
  expuoldpold: ((calcs.uold)^(1/((params.a)+(params.b))))*(((params.p1)/(calcs.s1))^(calcs.s1))*(((params.p2)/(calcs.s2))^(calcs.s2))

  # expenditure function at new utility and old prices
  expunewpold: ((calcs.unew)^(1/((params.a)+(params.b))))*(((params.p1)/(calcs.s1))^(calcs.s1))*(((params.p2)/(calcs.s2))^(calcs.s2))

  # expenditure function at old utility and new prices
  expuoldpnew: ((calcs.uold)^(1/((params.a)+(params.b))))*(((params.p1new)/(calcs.s1))^(calcs.s1))*(((params.p2)/(calcs.s2))^(calcs.s2))

  # expenditure function at new utility and new prices (=income)
  expunewpnew: ((calcs.unew)^(1/((params.a)+(params.b))))*(((params.p1new)/(calcs.s1))^(calcs.s1))*(((params.p2)/(calcs.s2))^(calcs.s2))

  EV: (calcs.expunewpnew)-(calcs.expunewpold)
  x1cunew: (calcs.s1)*((params.m)-(calcs.EV))/(params.p1) # hicksian demand of good 1 at new util and old prices
  x2cunew: (calcs.s2)*((params.m)-(calcs.EV))/(params.p2) # hicksian demand of good 2 at new util and old prices
  xmaxEV: ((params.m)-(calcs.EV))/params.p1
  ymaxEV: ((params.m)-(calcs.EV))/params.p2

  CV: (calcs.expuoldpnew)-(calcs.expuoldpold)
  x1cuold: (calcs.s1)*((params.m)+(calcs.CV))/(params.p1new) # hicksian demand of good 1 at old util and new prices
  x2cuold: (calcs.s2)*((params.m)+(calcs.CV))/(params.p2) # hicksian demand of good 2 at old util and new prices
  xmaxCV: ((params.m)+(calcs.CV))/params.p1new
  ymaxCV: ((params.m)+(calcs.CV))/params.p2


  maxX: (1.1)*(params.m)/(params.p1) # max displayed qty good 1
  maxY: (1.1)*(params.m)/(params.p2) # max displayed qty good 2
  maxEUR: (1.3)*(params.p1new) # max displayed price good 1

layout:
  TwoVerticalGraphsPlusSidebar:

    topGraph:
      xAxis:
        max: calcs.maxX
        ticks: 0
      yAxis:
        max: calcs.maxY
        ticks: 0
      objects:

      - Label:
            coordinates: [calcs.maxX, 0]
            text: "` \\\\text{Cibo (kg)} `"
            yPixelOffset: 0
            position: l
      - Label:
            coordinates: [0, calcs.maxY]
            text: "` \\\\text{Affitto ($\\\\text{m}^2$)}  `"
            yPixelOffset: 0

# old optimal bundle
      - Point:
          coordinates: [calcs.x1old, calcs.x2old]
          droplines:
            horizontal: calcs.x2old.toFixed(0)
            vertical: calcs.x1old.toFixed(0)
          color: Blue
          r: 3
      - Label:
          coordinates: [(1.05)*(calcs.x1old), (1.06)*(calcs.x2old)]
          text: "` A `"
#          position: l
          color: Blue
          bgcolor: none

# indifference curve at old optimal bundle
      - Curve:
          fn: ((calcs.uold)/((x)^(params.a)))^(1/(params.b))
          color: Black
          strokeWidth: 1.25
      
# old budget constraint 
      - Line:
          yIntercept: (params.m)/(params.p2)
          slope: -(params.p1)/(params.p2)
          color: Blue
          strokeWidth: 1.25
      - Point:
          coordinates: [(params.m)/(params.p1), 0]
          droplines:
            vertical: (params.m)/(params.p1)
          color: grey
          r: 0
      - Point:
          coordinates: [0,(params.m)/(params.p2)]
          droplines:
            horizontal: (params.m)/(params.p2)
          color: grey
          r: 0
      
# new budget constraint 
      - Line:
          yIntercept: (params.m)/(params.p2)
          slope: -(params.p1new)/(params.p2)
          color: Blue
          strokeWidth: 1.25
      - Point:
          coordinates: [(params.m)/(params.p1new), 0]
          droplines:
            vertical: (params.m)/(params.p1new)
          color: grey
          r: 0

# new optimal bundle
      - Point:
          coordinates: [calcs.x1new, calcs.x2new]
          droplines:
            horizontal: calcs.x2new.toFixed(0)
            vertical: calcs.x1new.toFixed(0)
          color: Blue
          r: 3
      - Label:
          coordinates: [(1.1)*(calcs.x1new), (1.06)*(calcs.x2new)]
          text: "` B `"
#          position: l
          color: Blue
          bgcolor: none

# indifference curve at new optimal bundle
      - Curve:
          fn: ((calcs.unew)/((x)^(params.a)))^(1/(params.b))
          color: Black
          strokeWidth: 1.25



# budget constraint with CV
      - Line:
          yIntercept: ((params.m)+(calcs.CV))/(params.p2)
          slope: -(params.p1new)/(params.p2)
          color: Red
          strokeWidth: 1.25
          show: params.howmuch == 2
      - Point:
          coordinates: [calcs.x1cuold, calcs.x2cuold]
          droplines:
            horizontal: calcs.x2cuold.toFixed(0)
            vertical: calcs.x1cuold.toFixed(0)
          color: Red
          r: 3
          show: params.howmuch == 2
      - Point:
          coordinates: [calcs.xmaxCV, 0]
          droplines:
            vertical: calcs.xmaxCV.toFixed(0)
          color: Red
          r: 0
          show: params.howmuch == 2
      - Point:
          coordinates: [0,calcs.ymaxCV]
          droplines:
            horizontal: calcs.ymaxCV.toFixed(0)
          color: Red
          r: 0
          show: params.howmuch == 2
      - Label:
          coordinates: [(1.08)*(calcs.x1cuold), (1.04)*(calcs.x2cuold)]
          text: "` C `"
#          position: l
          color: Red
          bgcolor: none
          show: params.howmuch == 2


# budget constraint with EV
      - Line:
          yIntercept: ((params.m)-(calcs.EV))/(params.p2)
          slope: -(params.p1)/(params.p2)
          color: Red
          strokeWidth: 1.25
          show: params.howmuch == 3
      - Point:
          coordinates: [calcs.x1cunew, calcs.x2cunew]
          droplines:
            horizontal: calcs.x2cunew.toFixed(0)
            vertical: calcs.x1cuold.toFixed(0)
          color: Red
          r: 3
          show: params.howmuch == 3
      - Point:
          coordinates: [calcs.xmaxEV, 0]
          droplines:
            vertical: calcs.xmaxEV.toFixed(0)
          color: Red
          r: 0
          show: params.howmuch == 3
      - Point:
          coordinates: [0,calcs.ymaxEV]
          droplines:
            horizontal: calcs.ymaxEV.toFixed(0)
          color: Red
          r: 0
          show: params.howmuch == 3
      - Label:
          coordinates: [(1.075)*(calcs.x1cunew), (1.075)*(calcs.x2cunew)]
          text: "` E `"
#          position: l
          color: Red
          bgcolor: none
          show: params.howmuch == 3














    bottomGraph:
      xAxis:
        max: calcs.maxX
        ticks: 0
      yAxis:
        max: calcs.maxEUR
        ticks: 0
      objects:

      - Label:
            coordinates: [calcs.maxX, 0]
            text: "` \\\\text{Cibo (kg)} `"
            yPixelOffset: 0
            position: l
      - Label:
            coordinates: [0, calcs.maxEUR]
            text: "` \\\\text{â‚¬/kg}  `"
            yPixelOffset: 0

# inverse demand for good 1
      - Curve:
          fn: (calcs.s1)*(params.m)/(x)
          color: Blue
          strokeWidth: 1.5

# old demand for good 1
      - Point:
          coordinates: [calcs.x1old, params.p1]
          droplines:
            horizontal: "` P_X=${params.p1} `"
            vertical: "` ${calcs.x1old.toFixed(0)} `"
          color: Blue
          r: 3.5

# new demand for good 1
      - Point:
          coordinates: [calcs.x1new, params.p1new]
          droplines:
            horizontal: "` P^\\\\prime_X=${params.p1new} `"
            vertical: "` ${calcs.x1new.toFixed(0)} `"
          color: Blue
          r: 3.5

# hicksian demand for good 1 at old utility
      - Curve:
          fn: ((params.a)/(params.b))*(params.p2)*((calcs.uold)^(1/(params.b)))*((x)^(-(1+((params.a)/(params.b)))))
          color: Red
          strokeWidth: 1.5
          show: params.howmuch == 2
      - Point:
          coordinates: [calcs.x1cuold, params.p1new]
          droplines:
            vertical: "` ${calcs.x1cuold.toFixed(0)} `"
          color: Red
          r: 3.5
          show: params.howmuch == 2
      - Segment:
          a: [calcs.x1cuold, params.p1new]
          b: [calcs.x1new, params.p1new]
          color: Red
          lineStyle: dotted
          show: params.howmuch == 2
      - Area:
          fn: min(params.p1new,((params.a)/(params.b))*(params.p2)*((calcs.uold)^(1/(params.b)))*((x)^(-(1+((params.a)/(params.b))))))
          fn2: (params.p1)
          fill: red
          min: 0.001
          max: calcs.x1old
          show: params.howmuch == 2
      - Label:
          coordinates: [(1.4)*(calcs.x1new)/2, ((params.p1)+(params.p1new))/2]
          text: "` CV = ${calcs.CV.toFixed(0)}  `"
          color: Red
          bgcolor: none
          show: params.howmuch == 2

# hicksian demand for good 1 at new utility
      - Curve:
          fn: ((params.a)/(params.b))*(params.p2)*((calcs.unew)^(1/(params.b)))*((x)^(-(1+((params.a)/(params.b)))))
          color: Red
          strokeWidth: 1.5
          show: params.howmuch == 3
      - Point:
          coordinates: [calcs.x1cunew, params.p1]
          droplines:
            vertical: "` ${calcs.x1cunew.toFixed(0)} `"
          color: Red
          r: 3.5
          show: params.howmuch == 3
      - Area:
          fn: min(params.p1new,((params.a)/(params.b))*(params.p2)*((calcs.unew)^(1/(params.b)))*((x)^(-(1+((params.a)/(params.b))))))
          fn2: (params.p1)
          fill: red
          min: 0.001
          max: calcs.x1cunew
          show: params.howmuch == 3
      - Label:
          coordinates: [(1.3)*(calcs.x1new)/2, (0.9)*((params.p1)+(params.p1new))/2]
          text: "` EV = ${calcs.EV.toFixed(0)}  `"
          color: Red
          bgcolor: none
          show: params.howmuch == 3

# compensation (CS)
      - Area:
          fn1: min((params.p1new),(calcs.s1)*(params.m)/(x))
          fn2: (params.p1)
          fill: blue
          min: 0.001
          max: calcs.x1old
          show: params.howmuch == 1
      - Label:
          coordinates: [(1.3)*(calcs.x1new)/2, (0.9)*((params.p1)+(params.p1new))/2]
          text: "` \\\\Delta CS = ${calcs.deltaCS.toFixed(2)}  `"
          color: Blue
          bgcolor: none
          show: params.howmuch == 1




    sidebar:
      controls:

      - title: Domanda compensata
        description: Scegliere il tipo di compensazione per visualizzare 
                      vincolo di bilancio e scelta ottima corrispondenti ai nuovi prezzi e al 
                      reddito compensato.

        radioGroup:
          param: howmuch
          options:
            - Nessuna compensazione
            - Variazione di surplus
            - Variazione compensativa
            - Variazione equivalente

        # checkboxes:
        # - param: showMORE
        #   label: "\\text{Mostra panieri preferiti ad $A$}"
        # - param: showLESS
        #   label: "\\text{Mostra panieri meno preferiti di $A$}"

        # sliders:
        # - param: a
        #   label: a
        # - param: b
        #   label: b

        divs:
          - html: "` `"
          - html: "` `"
          - html: "` `"
          - html: "` `"
          - html: "` $E(p,u)=${calcs.expuoldpold}$ `"
          - html: "` $E(p',u)=${calcs.expuoldpnew}$ `"
          - html: "` $E(p,u')=${calcs.expunewpold}$ `"
          - html: "` $E(p',u')=${calcs.expunewpnew}$ `"
          - html: "` $EV = ${calcs.EV}$ `"
          - html: "` $\\\\Delta CS = ${calcs.deltaCS}    $ `"
          - html: "` $CV = ${calcs.CV}$ `"
          - html: "` `"
          - html: "`
                  In assenza di compensazione, ai nuovi prezzi il consumatore
                  sceglie il paniere $B$.
                  `"
            show: params.howmuch == 0











