---
schema: EconSchema
version: 1
aspectRatio: 0.7
params:
  - {name: x1, value: 4, min: 0.5, max: 9, round: 0.5}
  - {name: x2, value: 4, min: 0.5, max: 9, round: 0.5}


# income and prices
  - {name: m, value: 30, min: 5, max: 45, round: 5}
  - {name: p1, value: 4, min: 1, max: 10, round: 0.5}
  - {name: p2, value: 4, min: 1, max: 10, round: 0.5}


# consumption levels on 45° line
  - {name: c1, value: 1}
  - {name: c2, value: 2}
  - {name: c3, value: 3}
  - {name: c4, value: 4}
  - {name: c5, value: 5}
  - {name: c6, value: 6}
  - {name: c7, value: 7}
  - {name: c8, value: 8}
  - {name: c9, value: 9}

  - {name: s, value: 10}



# which utility function
  - {name: whichU, value: 0}


calcs:

# optimal bundle and utility (params.whichU=0)
  x1opt0: (0.5)*(params.m)/(params.p1)
  x2opt0: (0.5)*(params.m)/(params.p2)
  u0: ((calcs.x1opt0))*((calcs.x2opt0))

# optimal bundle and utility (params.whichU=1)
  x1opt1: (2/3)*(params.m)/(params.p1)
  x2opt1: (1/3)*(params.m)/(params.p2)
  u1: ((calcs.x1opt1)^(2))*((calcs.x2opt1)^(1))

# optimal bundle and utility (params.whichU=2)
  x1opt2: (1/3)*(params.m)/(params.p1)
  x2opt2: (2/3)*(params.m)/(params.p2)
  u2: ((calcs.x1opt2)^(1))*((calcs.x2opt2)^(2))

# optimal bundle and utility (params.whichU=3)
  x1opt3: min(max(0,((params.m)+((params.s)*((params.p2)-(params.p1))))/((2)*(params.p1))),(params.m)/(params.p1))
  x2opt3: min(max(0,((params.m)+((params.s)*((params.p1)-(params.p2))))/((2)*(params.p2))),(params.m)/(params.p2))
  u3: ((calcs.x1opt3)*(calcs.x2opt3))+((params.s)*((calcs.x1opt3)+(calcs.x2opt3)))
  x1min: (params.m)/(calcs.minP1)



# price of X above which X=0
  maxP1: (params.p2)+(params.m)/(params.s)
# price of X below which Y=0
  minP1: (params.p2)-(params.m)/(params.s)




# MRS at selected bundle
  MRS0: (params.x2)/(params.x1)
  MRS1: (2)*(params.x2)/(params.x1)
  MRS2: (0.5)*(params.x2)/(params.x1)
  MRS3: ((params.x2)+(params.s))/((params.x1)+(params.s))

# utility levels (params.whichU=0)
  u10: ((params.c1))*((params.c1))
  u20: ((params.c2))*((params.c2))
  u30: ((params.c3))*((params.c3))
  u40: ((params.c4))*((params.c4))
  u50: ((params.c5))*((params.c5))
  u60: ((params.c6))*((params.c6))
  u70: ((params.c7))*((params.c7))
  u80: ((params.c8))*((params.c8))
  u90: ((params.c9))*((params.c9))

# utility levels (params.whichU=1)
  u11: ((params.c1)^(2))*((params.c1))
  u21: ((params.c2)^(2))*((params.c2))
  u31: ((params.c3)^(2))*((params.c3))
  u41: ((params.c4)^(2))*((params.c4))
  u51: ((params.c5)^(2))*((params.c5))
  u61: ((params.c6)^(2))*((params.c6))
  u71: ((params.c7)^(2))*((params.c7))
  u81: ((params.c8)^(2))*((params.c8))
  u91: ((params.c9)^(2))*((params.c9))

# utility levels (params.whichU=2)
  u12: ((params.c1))*((params.c1)^(2))
  u22: ((params.c2))*((params.c2)^(2))
  u32: ((params.c3))*((params.c3)^(2))
  u42: ((params.c4))*((params.c4)^(2))
  u52: ((params.c5))*((params.c5)^(2))
  u62: ((params.c6))*((params.c6)^(2))
  u72: ((params.c7))*((params.c7)^(2))
  u82: ((params.c8))*((params.c8)^(2))
  u92: ((params.c9))*((params.c9)^(2))

# utility levels (params.whichU=3)
  u13: ((params.c1)*(params.c1))+((params.s)*((params.c1)+(params.c1)))
  u23: ((params.c2)*(params.c2))+((params.s)*((params.c2)+(params.c2)))
  u33: ((params.c3)*(params.c3))+((params.s)*((params.c3)+(params.c3)))
  u43: ((params.c4)*(params.c4))+((params.s)*((params.c4)+(params.c4)))
  u53: ((params.c5)*(params.c5))+((params.s)*((params.c5)+(params.c5)))
  u63: ((params.c6)*(params.c6))+((params.s)*((params.c6)+(params.c6)))
  u73: ((params.c7)*(params.c7))+((params.s)*((params.c7)+(params.c7)))
  u83: ((params.c8)*(params.c8))+((params.s)*((params.c8)+(params.c8)))
  u93: ((params.c9)*(params.c9))+((params.s)*((params.c9)+(params.c9)))


  xintercept: params.m/params.p1
  yintercept: params.m/params.p2



layout:
  TwoVerticalGraphsPlusSidebar:


    topGraph:
      xAxis:
        max: 9.5
        ticks: 0
      yAxis:
        max: 9.5
        ticks: 0

      objects:

      - Label:
            coordinates: [9.33, 0]
            text: "` \\\\text{unità di $X$} `"
            position: l
      - Label:
            coordinates: [0, 9.5]
            text: "` \\\\text{unità di $Y$}  `"

# budget line
      - Line:
          point: [0,params.m/params.p2]
          slope: -params.p1/params.p2
          color: Green
          strokeWidth: 1.5
          max: params.m/params.p1
      - Point:
          coordinates: [params.m/params.p1, 0]
          droplines: {vertical: calcs.xintercept.toFixed(2), horizontal: }
          color: black
          r: 0
      - Point:
          coordinates: [0, params.m/params.p2]
          droplines: {vertical: , horizontal: calcs.yintercept.toFixed(2)}
          color: black
          r: 0

# optimal bundle
      - Point:
          coordinates: [calcs.x1opt0, calcs.x2opt0]
          droplines:
            horizontal: calcs.x2opt0.toFixed(2)
            vertical: calcs.x1opt0.toFixed(2)
          color: Blue
          r: 4
          strokeWidth: 0.5
          show: params.whichU == 0 
      - Point:
          coordinates: [calcs.x1opt1, calcs.x2opt1]
          droplines:
            horizontal: calcs.x2opt1.toFixed(2)
            vertical: calcs.x1opt1.toFixed(2)
          color: Blue
          r: 4
          strokeWidth: 0.5
          show: params.whichU == 1 
      - Point:
          coordinates: [calcs.x1opt2, calcs.x2opt2]
          droplines:
            horizontal: calcs.x2opt2.toFixed(2)
            vertical: calcs.x1opt2.toFixed(2)
          color: Blue
          r: 4
          strokeWidth: 0.5
          show: params.whichU == 2
      - Point:
          coordinates: [calcs.x1opt3, calcs.x2opt3]
          droplines:
            horizontal: calcs.x2opt3.toFixed(2)
            vertical: calcs.x1opt3.toFixed(2)
          color: Blue
          r: 4
          strokeWidth: 0.5
          show: params.whichU == 3

# Indifference curve at optimal bundle
      - Curve:
          fn: ((calcs.u0)/((x)^(1)))^(1/(1))
          color: Black
          strokeWidth: 1.5
          show: params.whichU == 0 
      - Curve:
          fn: ((calcs.u1)/((x)^(2)))^(1/(1))
          color: Black
          strokeWidth: 1.5
          show: params.whichU == 1 
      - Curve:
          fn: ((calcs.u2)/((x)^(1)))^(1/(2))
          color: Black
          strokeWidth: 1.5
          show: params.whichU == 2
      - Curve:
          fn: ((calcs.u3)-((params.s)*(x)))/((x)+(params.s))
          color: Black
          strokeWidth: 1.5
          show: params.whichU == 3
      

# Indifference Map (params.whichU=0)
      - Curve:
          fn:   ((calcs.u10)/((x)^(1)))^(1/(1))
          color: Grey
          strokeWidth: 0.2 
          min: 0.04
          show: params.whichU == 0 
      - Curve:
          fn:   ((calcs.u20)/((x)^(1)))^(1/(1))
          color: Grey
          strokeWidth: 0.2 
          min: 0.15
          show: params.whichU == 0 
      - Curve:
          fn:   ((calcs.u30)/((x)^(1)))^(1/(1))
          color: Grey
          strokeWidth: 0.2 
          min: 0.05
          show: params.whichU == 0 
      - Curve:
          fn:   ((calcs.u40)/((x)^(1)))^(1/(1))
          color: Grey
          strokeWidth: 0.2 
          min: 0.01
          show: params.whichU == 0 
      - Curve:
          fn:   ((calcs.u50)/((x)^(1)))^(1/(1))
          color: Grey
          strokeWidth: 0.2 
          min: 0.01
          show: params.whichU == 0 
      - Curve:
          fn:   ((calcs.u60)/((x)^(1)))^(1/(1))
          color: Grey
          strokeWidth: 0.2 
          min: 0.01
          show: params.whichU == 0 
      - Curve:
          fn:   ((calcs.u70)/((x)^(1)))^(1/(1))
          color: Grey
          strokeWidth: 0.2 
          min: 0.01
          show: params.whichU == 0 
      - Curve:
          fn:   ((calcs.u80)/((x)^(1)))^(1/(1))
          color: Grey
          strokeWidth: 0.2 
          min: 0.01
          show: params.whichU == 0 
      - Curve:
          fn:   ((calcs.u90)/((x)^(1)))^(1/(1))
          color: Grey
          strokeWidth: 0.2 
          min: 0.01
          show: params.whichU == 0 


# Indifference Map (params.whichU=1)
      - Curve:
          fn:   ((calcs.u11)/((x)^(2)))^(1/(1))
          color: Grey
          strokeWidth: 0.2 
          min: 0.04
          show: params.whichU == 1 
      - Curve:
          fn:   ((calcs.u21)/((x)^(2)))^(1/(1))
          color: Grey
          strokeWidth: 0.2 
          min: 0.15
          show: params.whichU == 1 
      - Curve:
          fn:   ((calcs.u31)/((x)^(2)))^(1/(1))
          color: Grey
          strokeWidth: 0.2 
          min: 0.05
          show: params.whichU == 1 
      - Curve:
          fn:   ((calcs.u41)/((x)^(2)))^(1/(1))
          color: Grey
          strokeWidth: 0.2 
          min: 0.01
          show: params.whichU == 1 
      - Curve:
          fn:   ((calcs.u51)/((x)^(2)))^(1/(1))
          color: Grey
          strokeWidth: 0.2 
          min: 0.01
          show: params.whichU == 1 
      - Curve:
          fn:   ((calcs.u61)/((x)^(2)))^(1/(1))
          color: Grey
          strokeWidth: 0.2 
          min: 0.01
          show: params.whichU == 1 
      - Curve:
          fn:   ((calcs.u71)/((x)^(2)))^(1/(1))
          color: Grey
          strokeWidth: 0.2 
          min: 0.01
          show: params.whichU == 1 
      - Curve:
          fn:   ((calcs.u81)/((x)^(2)))^(1/(1))
          color: Grey
          strokeWidth: 0.2 
          min: 0.01
          show: params.whichU == 1 
      - Curve:
          fn:   ((calcs.u91)/((x)^(2)))^(1/(1))
          color: Grey
          strokeWidth: 0.2 
          min: 0.01
          show: params.whichU == 1 


# Indifference Map (params.whichU=2)
      - Curve:
          fn:   ((calcs.u12)/((x)^(1)))^(1/(2))
          color: Grey
          strokeWidth: 0.2 
          min: 0.04
          show: params.whichU == 2 
      - Curve:
          fn:   ((calcs.u22)/((x)^(1)))^(1/(2))
          color: Grey
          strokeWidth: 0.2 
          min: 0.15
          show: params.whichU == 2 
      - Curve:
          fn:   ((calcs.u32)/((x)^(1)))^(1/(2))
          color: Grey
          strokeWidth: 0.2 
          min: 0.05
          show: params.whichU == 2 
      - Curve:
          fn:   ((calcs.u42)/((x)^(1)))^(1/(2))
          color: Grey
          strokeWidth: 0.2 
          min: 0.01
          show: params.whichU == 2 
      - Curve:
          fn:   ((calcs.u52)/((x)^(1)))^(1/(2))
          color: Grey
          strokeWidth: 0.2 
          min: 0.01
          show: params.whichU == 2 
      - Curve:
          fn:   ((calcs.u62)/((x)^(1)))^(1/(2))
          color: Grey
          strokeWidth: 0.2 
          min: 0.01
          show: params.whichU == 2 
      - Curve:
          fn:   ((calcs.u72)/((x)^(1)))^(1/(2))
          color: Grey
          strokeWidth: 0.2 
          min: 0.01
          show: params.whichU == 2 
      - Curve:
          fn:   ((calcs.u82)/((x)^(1)))^(1/(2))
          color: Grey
          strokeWidth: 0.2 
          min: 0.01
          show: params.whichU == 2 
      - Curve:
          fn:   ((calcs.u92)/((x)^(1)))^(1/(2))
          color: Grey
          strokeWidth: 0.2 
          min: 0.01
          show: params.whichU == 2 


# Indifference Map (params.whichU=3)
      - Curve:
          fn:   ((calcs.u13)-((params.s)*(x)))/((x)+(params.s))
          color: Grey
          strokeWidth: 0.2 
          min: 0.04
          show: params.whichU == 3 
      - Curve:
          fn:   ((calcs.u23)-((params.s)*(x)))/((x)+(params.s))
          color: Grey
          strokeWidth: 0.2 
          min: 0.04
          show: params.whichU == 3 
      - Curve:
          fn:   ((calcs.u33)-((params.s)*(x)))/((x)+(params.s))
          color: Grey
          strokeWidth: 0.2 
          min: 0.04
          show: params.whichU == 3 
      - Curve:
          fn:   ((calcs.u43)-((params.s)*(x)))/((x)+(params.s))
          color: Grey
          strokeWidth: 0.2 
          min: 0.04
          show: params.whichU == 3 
      - Curve:
          fn:   ((calcs.u53)-((params.s)*(x)))/((x)+(params.s))
          color: Grey
          strokeWidth: 0.2 
          min: 0.04
          show: params.whichU == 3 
      - Curve:
          fn:   ((calcs.u63)-((params.s)*(x)))/((x)+(params.s))
          color: Grey
          strokeWidth: 0.2 
          min: 0.04
          show: params.whichU == 3 
      - Curve:
          fn:   ((calcs.u73)-((params.s)*(x)))/((x)+(params.s))
          color: Grey
          strokeWidth: 0.2 
          min: 0.04
          show: params.whichU == 3 
      - Curve:
          fn:   ((calcs.u83)-((params.s)*(x)))/((x)+(params.s))
          color: Grey
          strokeWidth: 0.2 
          min: 0.04
          show: params.whichU == 3 
      - Curve:
          fn:   ((calcs.u93)-((params.s)*(x)))/((x)+(params.s))
          color: Grey
          strokeWidth: 0.2 
          min: 0.04
          show: params.whichU == 3 

























    bottomGraph:
      xAxis:
        max: 9.5
        ticks: 0
      yAxis:
        max: 9.5
        ticks: 0

      objects:

      - Label:
            coordinates: [9.33, 0]
            text: "` \\\\text{unità di $X$} `"
            position: l
      - Label:
            coordinates: [0, 9.5]
            text: "` \\\\text{euro/unità di $X$}  `"

# demand function
      - Curve:
          fn: (0.5)*(params.m)/(x)
          color: Blue
          strokeWidth: 1.5
          min: 0.04
          show: params.whichU == 0 
      - Curve:
          fn: (2/3)*(params.m)/(x)
          color: Blue
          strokeWidth: 1.5
          min: 0.04
          show: params.whichU == 1
      - Curve:
          fn: (1/3)*(params.m)/(x)
          color: Blue
          strokeWidth: 1.5
          min: 0.04
          show: params.whichU == 2 

# demand function (params.whichU=3)
      - Curve:
          fn: ((params.m)+(params.s)*(params.p2))/((2)*(x)+(params.s))
          color: Blue
          max: (params.m)/(calcs.minP1)
          strokeWidth: 2.5
          show: params.whichU == 3
      - Curve:
          fn: (params.m)/(x)
          color: Blue
          min: (params.m)/(calcs.minP1)
          strokeWidth: 2.5
          show: params.whichU == 3
      - Segment:
          a: [0.02, calcs.maxP1]
          b: [0.02, 1000]
          color: Blue
          strokeWidth: 3
          show: params.whichU == 3
      - Point:
          coordinates: [0, calcs.maxP1]
          droplines:
            horizontal: calcs.maxP1.toFixed(2)
          color: Blue
          r: 0
          show: params.whichU == 3
      - Point:
          coordinates: [(params.m)/(calcs.minP1), calcs.minP1]
          droplines:
            horizontal: calcs.minP1.toFixed(2)
            vertical: calcs.x1min.toFixed(2)
          color: Blue
          r: 0
          strokeWidth: 0.5
          show: params.whichU == 3

# optimal choice (params.whichU=0)
      - Point:
          coordinates: [calcs.x1opt0, params.p1]
          droplines:
            vertical: calcs.x1opt0.toFixed(2)
          color: Blue
          r: 4
          strokeWidth: 0.5
          show: params.whichU == 0 
      - Point:
          coordinates: [calcs.x1opt0, params.p1]
          droplines:
            horizontal: params.p1.toFixed(2)
          color: Green
          r: 0
          strokeWidth: 0.7
          show: params.whichU == 0 
# optimal choice (params.whichU=1)
      - Point:
          coordinates: [calcs.x1opt1, params.p1]
          droplines:
            vertical: calcs.x1opt1.toFixed(2)
          color: Blue
          r: 4
          strokeWidth: 0.5
          show: params.whichU == 1 
      - Point:
          coordinates: [calcs.x1opt1, params.p1]
          droplines:
            horizontal: params.p1.toFixed(2)
          color: Green
          r: 0
          strokeWidth: 0.7
          show: params.whichU == 1 
# optimal choice (params.whichU=2)
      - Point:
          coordinates: [calcs.x1opt2, params.p1]
          droplines:
            vertical: calcs.x1opt2.toFixed(2)
          color: Blue
          r: 4
          strokeWidth: 0.5
          show: params.whichU == 2 
      - Point:
          coordinates: [calcs.x1opt2, params.p1]
          droplines:
            horizontal: params.p1.toFixed(2)
          color: Green
          r: 0
          strokeWidth: 0.7
          show: params.whichU == 2 
# vertical dropline (params.whichU=2)
      - Segment:
          a: [calcs.x1opt2, params.p1]
          b: [calcs.x1opt2, 1000]
          strokeWidth: 0.6
          lineStyle: dotted
          color: blue
          show: params.whichU == 2 



# optimal choice (params.whichU=2)
      - Point:
          coordinates: [calcs.x1opt3, params.p1]
          droplines:
            vertical: calcs.x1opt3.toFixed(2)
          color: Blue
          r: 4
          strokeWidth: 0.5
          show: params.whichU == 3 && calcs.x1opt3 > 0
      - Point:
          coordinates: [0.02, params.p1]
          droplines:
            vertical: 0
          color: Blue
          r: 4
          strokeWidth: 0.5
          show: params.whichU == 3 && calcs.x1opt3 == 0
      - Point:
          coordinates: [calcs.x1opt3, params.p1]
          droplines:
            horizontal: params.p1.toFixed(2)
          color: Green
          r: 0
          strokeWidth: 0.7
          show: params.whichU == 3
# vertical dropline (params.whichU=2)
      - Segment:
          a: [calcs.x1opt3, params.p1]
          b: [calcs.x1opt3, 1000]
          strokeWidth: 0.6
          lineStyle: dotted
          color: blue
          show: params.whichU == 3 





















    sidebar:
      controls:
      - title: Utilità marginali e saggio marginale di sostituzione
        radioGroup:
          param: whichU
          options:
            - $U=XY$
            - $U=X^2Y$
            - $U=XY^2$
            - $U=XY+10(X+Y)$
        description: Selezionare una funzione di utilità. Selezionare poi reddito e prezzi per calcolare
                      la scelta ottima del consumatore e la funzione di domanda del bene 𝑋.

      - title: "` `"
        divs:
          - html: "`  `"
          - html: "` In questo caso abbiamo
                    $$ MU_X=Y \\\\qquad MU_Y=X$$
                    e quindi 
                    $$ MRS_{XY} = \\\\dfrac{Y}{X} $$  `"
        sliders:
        - param: m
          label: M
        - param: p1
          label: P_X
        - param: p2
          label: P_Y
        show: params.whichU == 0

      - title: "` `"
        divs:
          - html: "`  `"
          - html: "` In questo caso abbiamo
                    $$ MU_X=2XY \\\\qquad MU_Y=X^2$$
                    e quindi 
                    $$ MRS_{XY} = \\\\dfrac{2Y}{X} $$  `"
        sliders:
        - param: m
          label: M
        - param: p1
          label: P_X
        - param: p2
          label: P_Y
        show: params.whichU == 1

      - title: "` `"
        divs:
          - html: "`  `"
          - html: "` In questo caso abbiamo
                    $$ MU_X=Y^2 \\\\qquad MU_Y=2XY$$
                    e quindi 
                    $$ MRS_{XY} = \\\\dfrac{Y}{2X} $$  `"
        sliders:
        - param: m
          label: M
        - param: p1
          label: P_X
        - param: p2
          label: P_Y
        show: params.whichU == 2

      - title: "` `"
        divs:
          - html: "`  `"
          - html: "` In questo caso abbiamo
                    $$ MU_X=Y+${params.s} \\\\qquad MU_Y=X+${params.s}$$
                    e quindi 
                    $$ MRS_{XY} = \\\\dfrac{Y+${params.s}}{X+${params.s}} $$  `"
        sliders:
        - param: m
          label: M
        - param: p1
          label: P_X
        - param: p2
          label: P_Y
        show: params.whichU == 3









    explanation:

        divs:

          - html: "` `"

          - html: "` In corrispondenza del paniere $(${params.x1},${params.x2})$
                      le utilità marginali sono $MU_X=${params.x2}$ e $MU_Y=${params.x1}$.
                     Il saggio marginale di sostituzione di $X$ con $Y$ è quindi
                     $$ MRS_{XY} = \\\\dfrac{${params.x2}}{${params.x1}} = ${calcs.MRS0.toFixed(2)}. $$
                     `"
            show: params.whichU == 0

          - html: "` In corrispondenza del paniere $(${params.x1},${params.x2})$
                      le utilità marginali sono $MU_X=${(2)*(params.x1)*(params.x2)}$ e
                      $MU_Y=${(params.x1)*(params.x1)}$.
                     Il saggio marginale di sostituzione di $X$ con $Y$ è quindi
                     $$ MRS_{XY} = \\\\dfrac{2\\\\times ${params.x2}}{${params.x1}} = ${calcs.MRS1.toFixed(2)}. $$
                     `"
            show: params.whichU == 1

          - html: "` In corrispondenza del paniere $(${params.x1},${params.x2})$
                      le utilità marginali sono $MU_X=${(params.x2)*(params.x2)}$
                      e $MU_Y=${(2)*(params.x1)*(params.x2)}$.
                     Il saggio marginale di sostituzione di $X$ con $Y$ è quindi
                     $$ MRS_{XY} = \\\\dfrac{${params.x2}}{2 \\\\times ${params.x1}} = ${calcs.MRS2.toFixed(2)}. $$
                     `"
            show: params.whichU == 2

          - html: "` In corrispondenza del paniere $(${params.x1},${params.x2})$
                      le utilità marginali sono $MU_X=${(params.x2)+(params.s)}$
                      e $MU_Y=${(params.x1)+(params.s)}$.
                     Il saggio marginale di sostituzione di $X$ con $Y$ è quindi
                     $$ MRS_{XY} = \\\\dfrac{${params.x2}+${params.s}}{${params.x1}+${params.s}} = ${calcs.MRS3.toFixed(2)} $$
                     `"
            show: params.whichU == 3













